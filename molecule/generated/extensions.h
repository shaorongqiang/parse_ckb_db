// Generated by Molecule 0.7.3

#define MOLECULEC_VERSION 7003
#define MOLECULE_API_VERSION_MIN 7000

#include "molecule_reader.h"
#include "molecule_builder.h"

#ifndef EXTENSIONS_H
#define EXTENSIONS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef MOLECULE_API_DECORATOR
#define __DEFINE_MOLECULE_API_DECORATOR_EXTENSIONS
#define MOLECULE_API_DECORATOR
#endif /* MOLECULE_API_DECORATOR */

#include "blockchain.h"

/*
 * Reader APIs
 */

MOLECULE_API_DECORATOR  mol_errno       MolReader_BoolOpt_verify                        (const mol_seg_t*, bool);
#define                                 MolReader_BoolOpt_is_none(s)                    mol_option_is_none(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Byte32Opt_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_Byte32Opt_is_none(s)                  mol_option_is_none(s)
#define                                 MolReader_Bool_verify(s, c)                     mol_verify_fixed_size(s, 1)
#define                                 MolReader_Bool_get_nth0(s)                      mol_slice_by_offset(s, 0, 1)
#define                                 MolReader_BeUint32_verify(s, c)                 mol_verify_fixed_size(s, 4)
#define                                 MolReader_BeUint32_get_nth0(s)                  mol_slice_by_offset(s, 0, 1)
#define                                 MolReader_BeUint32_get_nth1(s)                  mol_slice_by_offset(s, 1, 1)
#define                                 MolReader_BeUint32_get_nth2(s)                  mol_slice_by_offset(s, 2, 1)
#define                                 MolReader_BeUint32_get_nth3(s)                  mol_slice_by_offset(s, 3, 1)
#define                                 MolReader_BeUint64_verify(s, c)                 mol_verify_fixed_size(s, 8)
#define                                 MolReader_BeUint64_get_nth0(s)                  mol_slice_by_offset(s, 0, 1)
#define                                 MolReader_BeUint64_get_nth1(s)                  mol_slice_by_offset(s, 1, 1)
#define                                 MolReader_BeUint64_get_nth2(s)                  mol_slice_by_offset(s, 2, 1)
#define                                 MolReader_BeUint64_get_nth3(s)                  mol_slice_by_offset(s, 3, 1)
#define                                 MolReader_BeUint64_get_nth4(s)                  mol_slice_by_offset(s, 4, 1)
#define                                 MolReader_BeUint64_get_nth5(s)                  mol_slice_by_offset(s, 5, 1)
#define                                 MolReader_BeUint64_get_nth6(s)                  mol_slice_by_offset(s, 6, 1)
#define                                 MolReader_BeUint64_get_nth7(s)                  mol_slice_by_offset(s, 7, 1)
#define                                 MolReader_Uint32Vec_verify(s, c)                mol_fixvec_verify(s, 4)
#define                                 MolReader_Uint32Vec_length(s)                   mol_fixvec_length(s)
#define                                 MolReader_Uint32Vec_get(s, i)                   mol_fixvec_slice_by_index(s, 4, i)
#define                                 MolReader_Uint64Vec_verify(s, c)                mol_fixvec_verify(s, 8)
#define                                 MolReader_Uint64Vec_length(s)                   mol_fixvec_length(s)
#define                                 MolReader_Uint64Vec_get(s, i)                   mol_fixvec_slice_by_index(s, 8, i)
MOLECULE_API_DECORATOR  mol_errno       MolReader_CellOutputOpt_verify                  (const mol_seg_t*, bool);
#define                                 MolReader_CellOutputOpt_is_none(s)              mol_option_is_none(s)
#define                                 MolReader_HeaderVec_verify(s, c)                mol_fixvec_verify(s, 208)
#define                                 MolReader_HeaderVec_length(s)                   mol_fixvec_length(s)
#define                                 MolReader_HeaderVec_get(s, i)                   mol_fixvec_slice_by_index(s, 208, i)
#define                                 MolReader_OutPointVec_verify(s, c)              mol_fixvec_verify(s, 36)
#define                                 MolReader_OutPointVec_length(s)                 mol_fixvec_length(s)
#define                                 MolReader_OutPointVec_get(s, i)                 mol_fixvec_slice_by_index(s, 36, i)
#define                                 MolReader_HeaderView_verify(s, c)               mol_verify_fixed_size(s, 240)
#define                                 MolReader_HeaderView_get_hash(s)                mol_slice_by_offset(s, 0, 32)
#define                                 MolReader_HeaderView_get_data(s)                mol_slice_by_offset(s, 32, 208)
MOLECULE_API_DECORATOR  mol_errno       MolReader_UncleBlockVecView_verify              (const mol_seg_t*, bool);
#define                                 MolReader_UncleBlockVecView_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_UncleBlockVecView_has_extra_fields(s) mol_table_has_extra_fields(s, 2)
#define                                 MolReader_UncleBlockVecView_get_hashes(s)       mol_table_slice_by_index(s, 0)
#define                                 MolReader_UncleBlockVecView_get_data(s)         mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_TransactionView_verify                (const mol_seg_t*, bool);
#define                                 MolReader_TransactionView_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_TransactionView_has_extra_fields(s)   mol_table_has_extra_fields(s, 3)
#define                                 MolReader_TransactionView_get_hash(s)           mol_table_slice_by_index(s, 0)
#define                                 MolReader_TransactionView_get_witness_hash(s)   mol_table_slice_by_index(s, 1)
#define                                 MolReader_TransactionView_get_data(s)           mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_BlockExt_verify                       (const mol_seg_t*, bool);
#define                                 MolReader_BlockExt_actual_field_count(s)        mol_table_actual_field_count(s)
#define                                 MolReader_BlockExt_has_extra_fields(s)          mol_table_has_extra_fields(s, 5)
#define                                 MolReader_BlockExt_get_total_difficulty(s)      mol_table_slice_by_index(s, 0)
#define                                 MolReader_BlockExt_get_total_uncles_count(s)    mol_table_slice_by_index(s, 1)
#define                                 MolReader_BlockExt_get_received_at(s)           mol_table_slice_by_index(s, 2)
#define                                 MolReader_BlockExt_get_txs_fees(s)              mol_table_slice_by_index(s, 3)
#define                                 MolReader_BlockExt_get_verified(s)              mol_table_slice_by_index(s, 4)
#define                                 MolReader_EpochExt_verify(s, c)                 mol_verify_fixed_size(s, 108)
#define                                 MolReader_EpochExt_get_previous_epoch_hash_rate(s) mol_slice_by_offset(s, 0, 32)
#define                                 MolReader_EpochExt_get_last_block_hash_in_previous_epoch(s) mol_slice_by_offset(s, 32, 32)
#define                                 MolReader_EpochExt_get_compact_target(s)        mol_slice_by_offset(s, 64, 4)
#define                                 MolReader_EpochExt_get_number(s)                mol_slice_by_offset(s, 68, 8)
#define                                 MolReader_EpochExt_get_base_block_reward(s)     mol_slice_by_offset(s, 76, 8)
#define                                 MolReader_EpochExt_get_remainder_reward(s)      mol_slice_by_offset(s, 84, 8)
#define                                 MolReader_EpochExt_get_start_number(s)          mol_slice_by_offset(s, 92, 8)
#define                                 MolReader_EpochExt_get_length(s)                mol_slice_by_offset(s, 100, 8)
#define                                 MolReader_TransactionKey_verify(s, c)           mol_verify_fixed_size(s, 36)
#define                                 MolReader_TransactionKey_get_block_hash(s)      mol_slice_by_offset(s, 0, 32)
#define                                 MolReader_TransactionKey_get_index(s)           mol_slice_by_offset(s, 32, 4)
#define                                 MolReader_NumberHash_verify(s, c)               mol_verify_fixed_size(s, 40)
#define                                 MolReader_NumberHash_get_number(s)              mol_slice_by_offset(s, 0, 8)
#define                                 MolReader_NumberHash_get_block_hash(s)          mol_slice_by_offset(s, 8, 32)
#define                                 MolReader_TransactionInfo_verify(s, c)          mol_verify_fixed_size(s, 52)
#define                                 MolReader_TransactionInfo_get_block_number(s)   mol_slice_by_offset(s, 0, 8)
#define                                 MolReader_TransactionInfo_get_block_epoch(s)    mol_slice_by_offset(s, 8, 8)
#define                                 MolReader_TransactionInfo_get_key(s)            mol_slice_by_offset(s, 16, 36)
MOLECULE_API_DECORATOR  mol_errno       MolReader_CellEntry_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_CellEntry_actual_field_count(s)       mol_table_actual_field_count(s)
#define                                 MolReader_CellEntry_has_extra_fields(s)         mol_table_has_extra_fields(s, 6)
#define                                 MolReader_CellEntry_get_output(s)               mol_table_slice_by_index(s, 0)
#define                                 MolReader_CellEntry_get_block_hash(s)           mol_table_slice_by_index(s, 1)
#define                                 MolReader_CellEntry_get_block_number(s)         mol_table_slice_by_index(s, 2)
#define                                 MolReader_CellEntry_get_block_epoch(s)          mol_table_slice_by_index(s, 3)
#define                                 MolReader_CellEntry_get_index(s)                mol_table_slice_by_index(s, 4)
#define                                 MolReader_CellEntry_get_data_size(s)            mol_table_slice_by_index(s, 5)
MOLECULE_API_DECORATOR  mol_errno       MolReader_CellDataEntry_verify                  (const mol_seg_t*, bool);
#define                                 MolReader_CellDataEntry_actual_field_count(s)   mol_table_actual_field_count(s)
#define                                 MolReader_CellDataEntry_has_extra_fields(s)     mol_table_has_extra_fields(s, 2)
#define                                 MolReader_CellDataEntry_get_output_data(s)      mol_table_slice_by_index(s, 0)
#define                                 MolReader_CellDataEntry_get_output_data_hash(s) mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RelayMessage_verify                   (const mol_seg_t*, bool);
#define                                 MolReader_RelayMessage_unpack(s)                mol_union_unpack(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_CompactBlock_verify                   (const mol_seg_t*, bool);
#define                                 MolReader_CompactBlock_actual_field_count(s)    mol_table_actual_field_count(s)
#define                                 MolReader_CompactBlock_has_extra_fields(s)      mol_table_has_extra_fields(s, 5)
#define                                 MolReader_CompactBlock_get_header(s)            mol_table_slice_by_index(s, 0)
#define                                 MolReader_CompactBlock_get_short_ids(s)         mol_table_slice_by_index(s, 1)
#define                                 MolReader_CompactBlock_get_prefilled_transactions(s) mol_table_slice_by_index(s, 2)
#define                                 MolReader_CompactBlock_get_uncles(s)            mol_table_slice_by_index(s, 3)
#define                                 MolReader_CompactBlock_get_proposals(s)         mol_table_slice_by_index(s, 4)
MOLECULE_API_DECORATOR  mol_errno       MolReader_CompactBlockV1_verify                 (const mol_seg_t*, bool);
#define                                 MolReader_CompactBlockV1_actual_field_count(s)  mol_table_actual_field_count(s)
#define                                 MolReader_CompactBlockV1_has_extra_fields(s)    mol_table_has_extra_fields(s, 6)
#define                                 MolReader_CompactBlockV1_get_header(s)          mol_table_slice_by_index(s, 0)
#define                                 MolReader_CompactBlockV1_get_short_ids(s)       mol_table_slice_by_index(s, 1)
#define                                 MolReader_CompactBlockV1_get_prefilled_transactions(s) mol_table_slice_by_index(s, 2)
#define                                 MolReader_CompactBlockV1_get_uncles(s)          mol_table_slice_by_index(s, 3)
#define                                 MolReader_CompactBlockV1_get_proposals(s)       mol_table_slice_by_index(s, 4)
#define                                 MolReader_CompactBlockV1_get_extension(s)       mol_table_slice_by_index(s, 5)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RelayTransaction_verify               (const mol_seg_t*, bool);
#define                                 MolReader_RelayTransaction_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_RelayTransaction_has_extra_fields(s)  mol_table_has_extra_fields(s, 2)
#define                                 MolReader_RelayTransaction_get_cycles(s)        mol_table_slice_by_index(s, 0)
#define                                 MolReader_RelayTransaction_get_transaction(s)   mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RelayTransactionVec_verify            (const mol_seg_t*, bool);
#define                                 MolReader_RelayTransactionVec_length(s)         mol_dynvec_length(s)
#define                                 MolReader_RelayTransactionVec_get(s, i)         mol_dynvec_slice_by_index(s, i)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RelayTransactions_verify              (const mol_seg_t*, bool);
#define                                 MolReader_RelayTransactions_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_RelayTransactions_has_extra_fields(s) mol_table_has_extra_fields(s, 1)
#define                                 MolReader_RelayTransactions_get_transactions(s) mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RelayTransactionHashes_verify         (const mol_seg_t*, bool);
#define                                 MolReader_RelayTransactionHashes_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_RelayTransactionHashes_has_extra_fields(s) mol_table_has_extra_fields(s, 1)
#define                                 MolReader_RelayTransactionHashes_get_tx_hashes(s) mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetRelayTransactions_verify           (const mol_seg_t*, bool);
#define                                 MolReader_GetRelayTransactions_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_GetRelayTransactions_has_extra_fields(s) mol_table_has_extra_fields(s, 1)
#define                                 MolReader_GetRelayTransactions_get_tx_hashes(s) mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetBlockTransactions_verify           (const mol_seg_t*, bool);
#define                                 MolReader_GetBlockTransactions_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_GetBlockTransactions_has_extra_fields(s) mol_table_has_extra_fields(s, 3)
#define                                 MolReader_GetBlockTransactions_get_block_hash(s) mol_table_slice_by_index(s, 0)
#define                                 MolReader_GetBlockTransactions_get_indexes(s)   mol_table_slice_by_index(s, 1)
#define                                 MolReader_GetBlockTransactions_get_uncle_indexes(s) mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_BlockTransactions_verify              (const mol_seg_t*, bool);
#define                                 MolReader_BlockTransactions_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_BlockTransactions_has_extra_fields(s) mol_table_has_extra_fields(s, 3)
#define                                 MolReader_BlockTransactions_get_block_hash(s)   mol_table_slice_by_index(s, 0)
#define                                 MolReader_BlockTransactions_get_transactions(s) mol_table_slice_by_index(s, 1)
#define                                 MolReader_BlockTransactions_get_uncles(s)       mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetBlockProposal_verify               (const mol_seg_t*, bool);
#define                                 MolReader_GetBlockProposal_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_GetBlockProposal_has_extra_fields(s)  mol_table_has_extra_fields(s, 2)
#define                                 MolReader_GetBlockProposal_get_block_hash(s)    mol_table_slice_by_index(s, 0)
#define                                 MolReader_GetBlockProposal_get_proposals(s)     mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_BlockProposal_verify                  (const mol_seg_t*, bool);
#define                                 MolReader_BlockProposal_actual_field_count(s)   mol_table_actual_field_count(s)
#define                                 MolReader_BlockProposal_has_extra_fields(s)     mol_table_has_extra_fields(s, 1)
#define                                 MolReader_BlockProposal_get_transactions(s)     mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_IndexTransaction_verify               (const mol_seg_t*, bool);
#define                                 MolReader_IndexTransaction_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_IndexTransaction_has_extra_fields(s)  mol_table_has_extra_fields(s, 2)
#define                                 MolReader_IndexTransaction_get_index(s)         mol_table_slice_by_index(s, 0)
#define                                 MolReader_IndexTransaction_get_transaction(s)   mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_IndexTransactionVec_verify            (const mol_seg_t*, bool);
#define                                 MolReader_IndexTransactionVec_length(s)         mol_dynvec_length(s)
#define                                 MolReader_IndexTransactionVec_get(s, i)         mol_dynvec_slice_by_index(s, i)
MOLECULE_API_DECORATOR  mol_errno       MolReader_SyncMessage_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_SyncMessage_unpack(s)                 mol_union_unpack(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetHeaders_verify                     (const mol_seg_t*, bool);
#define                                 MolReader_GetHeaders_actual_field_count(s)      mol_table_actual_field_count(s)
#define                                 MolReader_GetHeaders_has_extra_fields(s)        mol_table_has_extra_fields(s, 2)
#define                                 MolReader_GetHeaders_get_hash_stop(s)           mol_table_slice_by_index(s, 0)
#define                                 MolReader_GetHeaders_get_block_locator_hashes(s) mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetBlocks_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_GetBlocks_actual_field_count(s)       mol_table_actual_field_count(s)
#define                                 MolReader_GetBlocks_has_extra_fields(s)         mol_table_has_extra_fields(s, 1)
#define                                 MolReader_GetBlocks_get_block_hashes(s)         mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_SendHeaders_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_SendHeaders_actual_field_count(s)     mol_table_actual_field_count(s)
#define                                 MolReader_SendHeaders_has_extra_fields(s)       mol_table_has_extra_fields(s, 1)
#define                                 MolReader_SendHeaders_get_headers(s)            mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_SendBlock_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_SendBlock_actual_field_count(s)       mol_table_actual_field_count(s)
#define                                 MolReader_SendBlock_has_extra_fields(s)         mol_table_has_extra_fields(s, 1)
#define                                 MolReader_SendBlock_get_block(s)                mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_SetFilter_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_SetFilter_actual_field_count(s)       mol_table_actual_field_count(s)
#define                                 MolReader_SetFilter_has_extra_fields(s)         mol_table_has_extra_fields(s, 3)
#define                                 MolReader_SetFilter_get_hash_seed(s)            mol_table_slice_by_index(s, 0)
#define                                 MolReader_SetFilter_get_filter(s)               mol_table_slice_by_index(s, 1)
#define                                 MolReader_SetFilter_get_num_hashes(s)           mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_AddFilter_verify                      (const mol_seg_t*, bool);
#define                                 MolReader_AddFilter_actual_field_count(s)       mol_table_actual_field_count(s)
#define                                 MolReader_AddFilter_has_extra_fields(s)         mol_table_has_extra_fields(s, 1)
#define                                 MolReader_AddFilter_get_filter(s)               mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_ClearFilter_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_ClearFilter_actual_field_count(s)     mol_table_actual_field_count(s)
#define                                 MolReader_ClearFilter_has_extra_fields(s)       mol_table_has_extra_fields(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_FilteredBlock_verify                  (const mol_seg_t*, bool);
#define                                 MolReader_FilteredBlock_actual_field_count(s)   mol_table_actual_field_count(s)
#define                                 MolReader_FilteredBlock_has_extra_fields(s)     mol_table_has_extra_fields(s, 3)
#define                                 MolReader_FilteredBlock_get_header(s)           mol_table_slice_by_index(s, 0)
#define                                 MolReader_FilteredBlock_get_transactions(s)     mol_table_slice_by_index(s, 1)
#define                                 MolReader_FilteredBlock_get_proof(s)            mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_MerkleProof_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_MerkleProof_actual_field_count(s)     mol_table_actual_field_count(s)
#define                                 MolReader_MerkleProof_has_extra_fields(s)       mol_table_has_extra_fields(s, 2)
#define                                 MolReader_MerkleProof_get_indices(s)            mol_table_slice_by_index(s, 0)
#define                                 MolReader_MerkleProof_get_lemmas(s)             mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_InIBD_verify                          (const mol_seg_t*, bool);
#define                                 MolReader_InIBD_actual_field_count(s)           mol_table_actual_field_count(s)
#define                                 MolReader_InIBD_has_extra_fields(s)             mol_table_has_extra_fields(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Time_verify                           (const mol_seg_t*, bool);
#define                                 MolReader_Time_actual_field_count(s)            mol_table_actual_field_count(s)
#define                                 MolReader_Time_has_extra_fields(s)              mol_table_has_extra_fields(s, 1)
#define                                 MolReader_Time_get_timestamp(s)                 mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_RawAlert_verify                       (const mol_seg_t*, bool);
#define                                 MolReader_RawAlert_actual_field_count(s)        mol_table_actual_field_count(s)
#define                                 MolReader_RawAlert_has_extra_fields(s)          mol_table_has_extra_fields(s, 7)
#define                                 MolReader_RawAlert_get_notice_until(s)          mol_table_slice_by_index(s, 0)
#define                                 MolReader_RawAlert_get_id(s)                    mol_table_slice_by_index(s, 1)
#define                                 MolReader_RawAlert_get_cancel(s)                mol_table_slice_by_index(s, 2)
#define                                 MolReader_RawAlert_get_priority(s)              mol_table_slice_by_index(s, 3)
#define                                 MolReader_RawAlert_get_message(s)               mol_table_slice_by_index(s, 4)
#define                                 MolReader_RawAlert_get_min_version(s)           mol_table_slice_by_index(s, 5)
#define                                 MolReader_RawAlert_get_max_version(s)           mol_table_slice_by_index(s, 6)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Alert_verify                          (const mol_seg_t*, bool);
#define                                 MolReader_Alert_actual_field_count(s)           mol_table_actual_field_count(s)
#define                                 MolReader_Alert_has_extra_fields(s)             mol_table_has_extra_fields(s, 2)
#define                                 MolReader_Alert_get_raw(s)                      mol_table_slice_by_index(s, 0)
#define                                 MolReader_Alert_get_signatures(s)               mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Identify_verify                       (const mol_seg_t*, bool);
#define                                 MolReader_Identify_actual_field_count(s)        mol_table_actual_field_count(s)
#define                                 MolReader_Identify_has_extra_fields(s)          mol_table_has_extra_fields(s, 3)
#define                                 MolReader_Identify_get_flag(s)                  mol_table_slice_by_index(s, 0)
#define                                 MolReader_Identify_get_name(s)                  mol_table_slice_by_index(s, 1)
#define                                 MolReader_Identify_get_client_version(s)        mol_table_slice_by_index(s, 2)

/*
 * Builder APIs
 */

#define                                 MolBuilder_BoolOpt_init(b)                      mol_builder_initialize_fixed_size(b, 0)
#define                                 MolBuilder_BoolOpt_set(b, p, l)                 mol_option_builder_set(b, p, l)
#define                                 MolBuilder_BoolOpt_build(b)                     mol_builder_finalize_simple(b)
#define                                 MolBuilder_BoolOpt_clear(b)                     mol_builder_discard(b)
#define                                 MolBuilder_Byte32Opt_init(b)                    mol_builder_initialize_fixed_size(b, 0)
#define                                 MolBuilder_Byte32Opt_set(b, p, l)               mol_option_builder_set(b, p, l)
#define                                 MolBuilder_Byte32Opt_build(b)                   mol_builder_finalize_simple(b)
#define                                 MolBuilder_Byte32Opt_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_Bool_init(b)                         mol_builder_initialize_fixed_size(b, 1)
#define                                 MolBuilder_Bool_set_nth0(b, p)                  mol_builder_set_byte_by_offset(b, 0, p)
#define                                 MolBuilder_Bool_build(b)                        mol_builder_finalize_simple(b)
#define                                 MolBuilder_Bool_clear(b)                        mol_builder_discard(b)
#define                                 MolBuilder_BeUint32_init(b)                     mol_builder_initialize_fixed_size(b, 4)
#define                                 MolBuilder_BeUint32_set_nth0(b, p)              mol_builder_set_byte_by_offset(b, 0, p)
#define                                 MolBuilder_BeUint32_set_nth1(b, p)              mol_builder_set_byte_by_offset(b, 1, p)
#define                                 MolBuilder_BeUint32_set_nth2(b, p)              mol_builder_set_byte_by_offset(b, 2, p)
#define                                 MolBuilder_BeUint32_set_nth3(b, p)              mol_builder_set_byte_by_offset(b, 3, p)
#define                                 MolBuilder_BeUint32_build(b)                    mol_builder_finalize_simple(b)
#define                                 MolBuilder_BeUint32_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_BeUint64_init(b)                     mol_builder_initialize_fixed_size(b, 8)
#define                                 MolBuilder_BeUint64_set_nth0(b, p)              mol_builder_set_byte_by_offset(b, 0, p)
#define                                 MolBuilder_BeUint64_set_nth1(b, p)              mol_builder_set_byte_by_offset(b, 1, p)
#define                                 MolBuilder_BeUint64_set_nth2(b, p)              mol_builder_set_byte_by_offset(b, 2, p)
#define                                 MolBuilder_BeUint64_set_nth3(b, p)              mol_builder_set_byte_by_offset(b, 3, p)
#define                                 MolBuilder_BeUint64_set_nth4(b, p)              mol_builder_set_byte_by_offset(b, 4, p)
#define                                 MolBuilder_BeUint64_set_nth5(b, p)              mol_builder_set_byte_by_offset(b, 5, p)
#define                                 MolBuilder_BeUint64_set_nth6(b, p)              mol_builder_set_byte_by_offset(b, 6, p)
#define                                 MolBuilder_BeUint64_set_nth7(b, p)              mol_builder_set_byte_by_offset(b, 7, p)
#define                                 MolBuilder_BeUint64_build(b)                    mol_builder_finalize_simple(b)
#define                                 MolBuilder_BeUint64_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_Uint32Vec_init(b)                    mol_fixvec_builder_initialize(b, 64)
#define                                 MolBuilder_Uint32Vec_push(b, p)                 mol_fixvec_builder_push(b, p, 4)
#define                                 MolBuilder_Uint32Vec_build(b)                   mol_fixvec_builder_finalize(b)
#define                                 MolBuilder_Uint32Vec_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_Uint64Vec_init(b)                    mol_fixvec_builder_initialize(b, 128)
#define                                 MolBuilder_Uint64Vec_push(b, p)                 mol_fixvec_builder_push(b, p, 8)
#define                                 MolBuilder_Uint64Vec_build(b)                   mol_fixvec_builder_finalize(b)
#define                                 MolBuilder_Uint64Vec_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_CellOutputOpt_init(b)                mol_builder_initialize_fixed_size(b, 0)
#define                                 MolBuilder_CellOutputOpt_set(b, p, l)           mol_option_builder_set(b, p, l)
#define                                 MolBuilder_CellOutputOpt_build(b)               mol_builder_finalize_simple(b)
#define                                 MolBuilder_CellOutputOpt_clear(b)               mol_builder_discard(b)
#define                                 MolBuilder_HeaderVec_init(b)                    mol_fixvec_builder_initialize(b, 4096)
#define                                 MolBuilder_HeaderVec_push(b, p)                 mol_fixvec_builder_push(b, p, 208)
#define                                 MolBuilder_HeaderVec_build(b)                   mol_fixvec_builder_finalize(b)
#define                                 MolBuilder_HeaderVec_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_OutPointVec_init(b)                  mol_fixvec_builder_initialize(b, 1024)
#define                                 MolBuilder_OutPointVec_push(b, p)               mol_fixvec_builder_push(b, p, 36)
#define                                 MolBuilder_OutPointVec_build(b)                 mol_fixvec_builder_finalize(b)
#define                                 MolBuilder_OutPointVec_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_HeaderView_init(b)                   mol_builder_initialize_fixed_size(b, 240)
#define                                 MolBuilder_HeaderView_set_hash(b, p)            mol_builder_set_by_offset(b, 0, p, 32)
#define                                 MolBuilder_HeaderView_set_data(b, p)            mol_builder_set_by_offset(b, 32, p, 208)
#define                                 MolBuilder_HeaderView_build(b)                  mol_builder_finalize_simple(b)
#define                                 MolBuilder_HeaderView_clear(b)                  mol_builder_discard(b)
#define                                 MolBuilder_UncleBlockVecView_init(b)            mol_table_builder_initialize(b, 128, 2)
#define                                 MolBuilder_UncleBlockVecView_set_hashes(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_UncleBlockVecView_set_data(b, p, l)  mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_UncleBlockVecView_build              (mol_builder_t);
#define                                 MolBuilder_UncleBlockVecView_clear(b)           mol_builder_discard(b)
#define                                 MolBuilder_TransactionView_init(b)              mol_table_builder_initialize(b, 1024, 3)
#define                                 MolBuilder_TransactionView_set_hash(b, p, l)    mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_TransactionView_set_witness_hash(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_TransactionView_set_data(b, p, l)    mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_TransactionView_build                (mol_builder_t);
#define                                 MolBuilder_TransactionView_clear(b)             mol_builder_discard(b)
#define                                 MolBuilder_BlockExt_init(b)                     mol_table_builder_initialize(b, 512, 5)
#define                                 MolBuilder_BlockExt_set_total_difficulty(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_BlockExt_set_total_uncles_count(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_BlockExt_set_received_at(b, p, l)    mol_table_builder_add(b, 2, p, l)
#define                                 MolBuilder_BlockExt_set_txs_fees(b, p, l)       mol_table_builder_add(b, 3, p, l)
#define                                 MolBuilder_BlockExt_set_verified(b, p, l)       mol_table_builder_add(b, 4, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_BlockExt_build                       (mol_builder_t);
#define                                 MolBuilder_BlockExt_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_EpochExt_init(b)                     mol_builder_initialize_fixed_size(b, 108)
#define                                 MolBuilder_EpochExt_set_previous_epoch_hash_rate(b, p) mol_builder_set_by_offset(b, 0, p, 32)
#define                                 MolBuilder_EpochExt_set_last_block_hash_in_previous_epoch(b, p) mol_builder_set_by_offset(b, 32, p, 32)
#define                                 MolBuilder_EpochExt_set_compact_target(b, p)    mol_builder_set_by_offset(b, 64, p, 4)
#define                                 MolBuilder_EpochExt_set_number(b, p)            mol_builder_set_by_offset(b, 68, p, 8)
#define                                 MolBuilder_EpochExt_set_base_block_reward(b, p) mol_builder_set_by_offset(b, 76, p, 8)
#define                                 MolBuilder_EpochExt_set_remainder_reward(b, p)  mol_builder_set_by_offset(b, 84, p, 8)
#define                                 MolBuilder_EpochExt_set_start_number(b, p)      mol_builder_set_by_offset(b, 92, p, 8)
#define                                 MolBuilder_EpochExt_set_length(b, p)            mol_builder_set_by_offset(b, 100, p, 8)
#define                                 MolBuilder_EpochExt_build(b)                    mol_builder_finalize_simple(b)
#define                                 MolBuilder_EpochExt_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_TransactionKey_init(b)               mol_builder_initialize_fixed_size(b, 36)
#define                                 MolBuilder_TransactionKey_set_block_hash(b, p)  mol_builder_set_by_offset(b, 0, p, 32)
#define                                 MolBuilder_TransactionKey_set_index(b, p)       mol_builder_set_by_offset(b, 32, p, 4)
#define                                 MolBuilder_TransactionKey_build(b)              mol_builder_finalize_simple(b)
#define                                 MolBuilder_TransactionKey_clear(b)              mol_builder_discard(b)
#define                                 MolBuilder_NumberHash_init(b)                   mol_builder_initialize_fixed_size(b, 40)
#define                                 MolBuilder_NumberHash_set_number(b, p)          mol_builder_set_by_offset(b, 0, p, 8)
#define                                 MolBuilder_NumberHash_set_block_hash(b, p)      mol_builder_set_by_offset(b, 8, p, 32)
#define                                 MolBuilder_NumberHash_build(b)                  mol_builder_finalize_simple(b)
#define                                 MolBuilder_NumberHash_clear(b)                  mol_builder_discard(b)
#define                                 MolBuilder_TransactionInfo_init(b)              mol_builder_initialize_fixed_size(b, 52)
#define                                 MolBuilder_TransactionInfo_set_block_number(b, p) mol_builder_set_by_offset(b, 0, p, 8)
#define                                 MolBuilder_TransactionInfo_set_block_epoch(b, p) mol_builder_set_by_offset(b, 8, p, 8)
#define                                 MolBuilder_TransactionInfo_set_key(b, p)        mol_builder_set_by_offset(b, 16, p, 36)
#define                                 MolBuilder_TransactionInfo_build(b)             mol_builder_finalize_simple(b)
#define                                 MolBuilder_TransactionInfo_clear(b)             mol_builder_discard(b)
#define                                 MolBuilder_CellEntry_init(b)                    mol_table_builder_initialize(b, 1024, 6)
#define                                 MolBuilder_CellEntry_set_output(b, p, l)        mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_CellEntry_set_block_hash(b, p, l)    mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_CellEntry_set_block_number(b, p, l)  mol_table_builder_add(b, 2, p, l)
#define                                 MolBuilder_CellEntry_set_block_epoch(b, p, l)   mol_table_builder_add(b, 3, p, l)
#define                                 MolBuilder_CellEntry_set_index(b, p, l)         mol_table_builder_add(b, 4, p, l)
#define                                 MolBuilder_CellEntry_set_data_size(b, p, l)     mol_table_builder_add(b, 5, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_CellEntry_build                      (mol_builder_t);
#define                                 MolBuilder_CellEntry_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_CellDataEntry_init(b)                mol_table_builder_initialize(b, 256, 2)
#define                                 MolBuilder_CellDataEntry_set_output_data(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_CellDataEntry_set_output_data_hash(b, p, l) mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_CellDataEntry_build                  (mol_builder_t);
#define                                 MolBuilder_CellDataEntry_clear(b)               mol_builder_discard(b)
#define                                 MolBuilder_RelayMessage_init(b)                 mol_union_builder_initialize(b, 256, 0, &MolDefault_CompactBlock, 248)
#define                                 MolBuilder_RelayMessage_set_CompactBlock(b, p, l) mol_union_builder_set(b, 0, p, l)
#define                                 MolBuilder_RelayMessage_set_RelayTransactions(b, p, l) mol_union_builder_set(b, 1, p, l)
#define                                 MolBuilder_RelayMessage_set_RelayTransactionHashes(b, p, l) mol_union_builder_set(b, 2, p, l)
#define                                 MolBuilder_RelayMessage_set_GetRelayTransactions(b, p, l) mol_union_builder_set(b, 3, p, l)
#define                                 MolBuilder_RelayMessage_set_GetBlockTransactions(b, p, l) mol_union_builder_set(b, 4, p, l)
#define                                 MolBuilder_RelayMessage_set_BlockTransactions(b, p, l) mol_union_builder_set(b, 5, p, l)
#define                                 MolBuilder_RelayMessage_set_GetBlockProposal(b, p, l) mol_union_builder_set(b, 6, p, l)
#define                                 MolBuilder_RelayMessage_set_BlockProposal(b, p, l) mol_union_builder_set(b, 7, p, l)
#define                                 MolBuilder_RelayMessage_build(b)                mol_builder_finalize_simple(b)
#define                                 MolBuilder_RelayMessage_clear(b)                mol_builder_discard(b)
#define                                 MolBuilder_CompactBlock_init(b)                 mol_table_builder_initialize(b, 1024, 5)
#define                                 MolBuilder_CompactBlock_set_header(b, p, l)     mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_CompactBlock_set_short_ids(b, p, l)  mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_CompactBlock_set_prefilled_transactions(b, p, l) mol_table_builder_add(b, 2, p, l)
#define                                 MolBuilder_CompactBlock_set_uncles(b, p, l)     mol_table_builder_add(b, 3, p, l)
#define                                 MolBuilder_CompactBlock_set_proposals(b, p, l)  mol_table_builder_add(b, 4, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_CompactBlock_build                   (mol_builder_t);
#define                                 MolBuilder_CompactBlock_clear(b)                mol_builder_discard(b)
#define                                 MolBuilder_CompactBlockV1_init(b)               mol_table_builder_initialize(b, 1024, 6)
#define                                 MolBuilder_CompactBlockV1_set_header(b, p, l)   mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_CompactBlockV1_set_short_ids(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_CompactBlockV1_set_prefilled_transactions(b, p, l) mol_table_builder_add(b, 2, p, l)
#define                                 MolBuilder_CompactBlockV1_set_uncles(b, p, l)   mol_table_builder_add(b, 3, p, l)
#define                                 MolBuilder_CompactBlockV1_set_proposals(b, p, l) mol_table_builder_add(b, 4, p, l)
#define                                 MolBuilder_CompactBlockV1_set_extension(b, p, l) mol_table_builder_add(b, 5, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_CompactBlockV1_build                 (mol_builder_t);
#define                                 MolBuilder_CompactBlockV1_clear(b)              mol_builder_discard(b)
#define                                 MolBuilder_RelayTransaction_init(b)             mol_table_builder_initialize(b, 512, 2)
#define                                 MolBuilder_RelayTransaction_set_cycles(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_RelayTransaction_set_transaction(b, p, l) mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_RelayTransaction_build               (mol_builder_t);
#define                                 MolBuilder_RelayTransaction_clear(b)            mol_builder_discard(b)
#define                                 MolBuilder_RelayTransactionVec_init(b)          mol_builder_initialize_with_capacity(b, 2048, 64)
#define                                 MolBuilder_RelayTransactionVec_push(b, p, l)    mol_dynvec_builder_push(b, p, l)
#define                                 MolBuilder_RelayTransactionVec_build(b)         mol_dynvec_builder_finalize(b)
#define                                 MolBuilder_RelayTransactionVec_clear(b)         mol_builder_discard(b)
#define                                 MolBuilder_RelayTransactions_init(b)            mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_RelayTransactions_set_transactions(b, p, l) mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_RelayTransactions_build              (mol_builder_t);
#define                                 MolBuilder_RelayTransactions_clear(b)           mol_builder_discard(b)
#define                                 MolBuilder_RelayTransactionHashes_init(b)       mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_RelayTransactionHashes_set_tx_hashes(b, p, l) mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_RelayTransactionHashes_build         (mol_builder_t);
#define                                 MolBuilder_RelayTransactionHashes_clear(b)      mol_builder_discard(b)
#define                                 MolBuilder_GetRelayTransactions_init(b)         mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_GetRelayTransactions_set_tx_hashes(b, p, l) mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetRelayTransactions_build           (mol_builder_t);
#define                                 MolBuilder_GetRelayTransactions_clear(b)        mol_builder_discard(b)
#define                                 MolBuilder_GetBlockTransactions_init(b)         mol_table_builder_initialize(b, 256, 3)
#define                                 MolBuilder_GetBlockTransactions_set_block_hash(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_GetBlockTransactions_set_indexes(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_GetBlockTransactions_set_uncle_indexes(b, p, l) mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetBlockTransactions_build           (mol_builder_t);
#define                                 MolBuilder_GetBlockTransactions_clear(b)        mol_builder_discard(b)
#define                                 MolBuilder_BlockTransactions_init(b)            mol_table_builder_initialize(b, 256, 3)
#define                                 MolBuilder_BlockTransactions_set_block_hash(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_BlockTransactions_set_transactions(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_BlockTransactions_set_uncles(b, p, l) mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_BlockTransactions_build              (mol_builder_t);
#define                                 MolBuilder_BlockTransactions_clear(b)           mol_builder_discard(b)
#define                                 MolBuilder_GetBlockProposal_init(b)             mol_table_builder_initialize(b, 256, 2)
#define                                 MolBuilder_GetBlockProposal_set_block_hash(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_GetBlockProposal_set_proposals(b, p, l) mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetBlockProposal_build               (mol_builder_t);
#define                                 MolBuilder_GetBlockProposal_clear(b)            mol_builder_discard(b)
#define                                 MolBuilder_BlockProposal_init(b)                mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_BlockProposal_set_transactions(b, p, l) mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_BlockProposal_build                  (mol_builder_t);
#define                                 MolBuilder_BlockProposal_clear(b)               mol_builder_discard(b)
#define                                 MolBuilder_IndexTransaction_init(b)             mol_table_builder_initialize(b, 512, 2)
#define                                 MolBuilder_IndexTransaction_set_index(b, p, l)  mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_IndexTransaction_set_transaction(b, p, l) mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_IndexTransaction_build               (mol_builder_t);
#define                                 MolBuilder_IndexTransaction_clear(b)            mol_builder_discard(b)
#define                                 MolBuilder_IndexTransactionVec_init(b)          mol_builder_initialize_with_capacity(b, 2048, 64)
#define                                 MolBuilder_IndexTransactionVec_push(b, p, l)    mol_dynvec_builder_push(b, p, l)
#define                                 MolBuilder_IndexTransactionVec_build(b)         mol_dynvec_builder_finalize(b)
#define                                 MolBuilder_IndexTransactionVec_clear(b)         mol_builder_discard(b)
#define                                 MolBuilder_SyncMessage_init(b)                  mol_union_builder_initialize(b, 64, 0, &MolDefault_GetHeaders, 48)
#define                                 MolBuilder_SyncMessage_set_GetHeaders(b, p, l)  mol_union_builder_set(b, 0, p, l)
#define                                 MolBuilder_SyncMessage_set_SendHeaders(b, p, l) mol_union_builder_set(b, 1, p, l)
#define                                 MolBuilder_SyncMessage_set_GetBlocks(b, p, l)   mol_union_builder_set(b, 2, p, l)
#define                                 MolBuilder_SyncMessage_set_SendBlock(b, p, l)   mol_union_builder_set(b, 3, p, l)
#define                                 MolBuilder_SyncMessage_set_SetFilter(b, p, l)   mol_union_builder_set(b, 4, p, l)
#define                                 MolBuilder_SyncMessage_set_AddFilter(b, p, l)   mol_union_builder_set(b, 5, p, l)
#define                                 MolBuilder_SyncMessage_set_ClearFilter(b, p, l) mol_union_builder_set(b, 6, p, l)
#define                                 MolBuilder_SyncMessage_set_FilteredBlock(b, p, l) mol_union_builder_set(b, 7, p, l)
#define                                 MolBuilder_SyncMessage_set_InIBD(b, p, l)       mol_union_builder_set(b, 8, p, l)
#define                                 MolBuilder_SyncMessage_build(b)                 mol_builder_finalize_simple(b)
#define                                 MolBuilder_SyncMessage_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_GetHeaders_init(b)                   mol_table_builder_initialize(b, 256, 2)
#define                                 MolBuilder_GetHeaders_set_hash_stop(b, p, l)    mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_GetHeaders_set_block_locator_hashes(b, p, l) mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetHeaders_build                     (mol_builder_t);
#define                                 MolBuilder_GetHeaders_clear(b)                  mol_builder_discard(b)
#define                                 MolBuilder_GetBlocks_init(b)                    mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_GetBlocks_set_block_hashes(b, p, l)  mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetBlocks_build                      (mol_builder_t);
#define                                 MolBuilder_GetBlocks_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_SendHeaders_init(b)                  mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_SendHeaders_set_headers(b, p, l)     mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_SendHeaders_build                    (mol_builder_t);
#define                                 MolBuilder_SendHeaders_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_SendBlock_init(b)                    mol_table_builder_initialize(b, 1024, 1)
#define                                 MolBuilder_SendBlock_set_block(b, p, l)         mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_SendBlock_build                      (mol_builder_t);
#define                                 MolBuilder_SendBlock_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_SetFilter_init(b)                    mol_table_builder_initialize(b, 128, 3)
#define                                 MolBuilder_SetFilter_set_hash_seed(b, p, l)     mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_SetFilter_set_filter(b, p, l)        mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_SetFilter_set_num_hashes(b, p)       mol_table_builder_add_byte(b, 2, p)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_SetFilter_build                      (mol_builder_t);
#define                                 MolBuilder_SetFilter_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_AddFilter_init(b)                    mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_AddFilter_set_filter(b, p, l)        mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_AddFilter_build                      (mol_builder_t);
#define                                 MolBuilder_AddFilter_clear(b)                   mol_builder_discard(b)
#define                                 MolBuilder_ClearFilter_init(b)                  mol_table_builder_initialize(b, 16, 0)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_ClearFilter_build                    (mol_builder_t);
#define                                 MolBuilder_ClearFilter_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_FilteredBlock_init(b)                mol_table_builder_initialize(b, 1024, 3)
#define                                 MolBuilder_FilteredBlock_set_header(b, p, l)    mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_FilteredBlock_set_transactions(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_FilteredBlock_set_proof(b, p, l)     mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_FilteredBlock_build                  (mol_builder_t);
#define                                 MolBuilder_FilteredBlock_clear(b)               mol_builder_discard(b)
#define                                 MolBuilder_MerkleProof_init(b)                  mol_table_builder_initialize(b, 128, 2)
#define                                 MolBuilder_MerkleProof_set_indices(b, p, l)     mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_MerkleProof_set_lemmas(b, p, l)      mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_MerkleProof_build                    (mol_builder_t);
#define                                 MolBuilder_MerkleProof_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_InIBD_init(b)                        mol_table_builder_initialize(b, 16, 0)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_InIBD_build                          (mol_builder_t);
#define                                 MolBuilder_InIBD_clear(b)                       mol_builder_discard(b)
#define                                 MolBuilder_Time_init(b)                         mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_Time_set_timestamp(b, p, l)          mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Time_build                           (mol_builder_t);
#define                                 MolBuilder_Time_clear(b)                        mol_builder_discard(b)
#define                                 MolBuilder_RawAlert_init(b)                     mol_table_builder_initialize(b, 256, 7)
#define                                 MolBuilder_RawAlert_set_notice_until(b, p, l)   mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_RawAlert_set_id(b, p, l)             mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_RawAlert_set_cancel(b, p, l)         mol_table_builder_add(b, 2, p, l)
#define                                 MolBuilder_RawAlert_set_priority(b, p, l)       mol_table_builder_add(b, 3, p, l)
#define                                 MolBuilder_RawAlert_set_message(b, p, l)        mol_table_builder_add(b, 4, p, l)
#define                                 MolBuilder_RawAlert_set_min_version(b, p, l)    mol_table_builder_add(b, 5, p, l)
#define                                 MolBuilder_RawAlert_set_max_version(b, p, l)    mol_table_builder_add(b, 6, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_RawAlert_build                       (mol_builder_t);
#define                                 MolBuilder_RawAlert_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_Alert_init(b)                        mol_table_builder_initialize(b, 512, 2)
#define                                 MolBuilder_Alert_set_raw(b, p, l)               mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_Alert_set_signatures(b, p, l)        mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Alert_build                          (mol_builder_t);
#define                                 MolBuilder_Alert_clear(b)                       mol_builder_discard(b)
#define                                 MolBuilder_Identify_init(b)                     mol_table_builder_initialize(b, 128, 3)
#define                                 MolBuilder_Identify_set_flag(b, p, l)           mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_Identify_set_name(b, p, l)           mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_Identify_set_client_version(b, p, l) mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Identify_build                       (mol_builder_t);
#define                                 MolBuilder_Identify_clear(b)                    mol_builder_discard(b)

/*
 * Default Value
 */

#define ____ 0x00

MOLECULE_API_DECORATOR const uint8_t MolDefault_BoolOpt[0]       =  {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Byte32Opt[0]     =  {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Bool[1]          =  {____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BeUint32[4]      =  {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BeUint64[8]      =  {
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint32Vec[4]     =  {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint64Vec[4]     =  {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellOutputOpt[0] =  {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_HeaderVec[4]     =  {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_OutPointVec[4]   =  {____, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_HeaderView[240]  =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_UncleBlockVecView[20] =  {
    0x14, ____, ____, ____, 0x0c, ____, ____, ____, 0x10, ____, ____, ____,
    ____, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_TransactionView[148] =  {
    0x94, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x50, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x44, ____, ____, ____,
    0x0c, ____, ____, ____, 0x40, ____, ____, ____, 0x34, ____, ____, ____,
    0x1c, ____, ____, ____, 0x20, ____, ____, ____, 0x24, ____, ____, ____,
    0x28, ____, ____, ____, 0x2c, ____, ____, ____, 0x30, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____,
    0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BlockExt[76]     =  {
    0x4c, ____, ____, ____, 0x18, ____, ____, ____, 0x38, ____, ____, ____,
    0x40, ____, ____, ____, 0x48, ____, ____, ____, 0x4c, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_EpochExt[108]    =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_TransactionKey[36] =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_NumberHash[40]   =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_TransactionInfo[52] =  {
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellEntry[165]   =  {
    0xa5, ____, ____, ____, 0x1c, ____, ____, ____, 0x69, ____, ____, ____,
    0x89, ____, ____, ____, 0x91, ____, ____, ____, 0x99, ____, ____, ____,
    0x9d, ____, ____, ____, 0x4d, ____, ____, ____, 0x10, ____, ____, ____,
    0x18, ____, ____, ____, 0x4d, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, 0x35, ____, ____, ____, 0x10, ____, ____, ____,
    0x30, ____, ____, ____, 0x31, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CellDataEntry[48] =  {
    0x30, ____, ____, ____, 0x0c, ____, ____, ____, 0x10, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RelayMessage[252] =  {
    ____, ____, ____, ____, 0xf8, ____, ____, ____, 0x18, ____, ____, ____,
    0xe8, ____, ____, ____, 0xec, ____, ____, ____, 0xf0, ____, ____, ____,
    0xf4, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CompactBlock[248] =  {
    0xf8, ____, ____, ____, 0x18, ____, ____, ____, 0xe8, ____, ____, ____,
    0xec, ____, ____, ____, 0xf0, ____, ____, ____, 0xf4, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_CompactBlockV1[256] =  {
    ____, 0x01, ____, ____, 0x1c, ____, ____, ____, 0xec, ____, ____, ____,
    0xf0, ____, ____, ____, 0xf4, ____, ____, ____, 0xf8, ____, ____, ____,
    0xfc, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RelayTransaction[88] =  {
    0x58, ____, ____, ____, 0x0c, ____, ____, ____, 0x14, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x44, ____, ____, ____,
    0x0c, ____, ____, ____, 0x40, ____, ____, ____, 0x34, ____, ____, ____,
    0x1c, ____, ____, ____, 0x20, ____, ____, ____, 0x24, ____, ____, ____,
    0x28, ____, ____, ____, 0x2c, ____, ____, ____, 0x30, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____,
    0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RelayTransactionVec[4] =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RelayTransactions[12] =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RelayTransactionHashes[12] =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetRelayTransactions[12] =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetBlockTransactions[56] =  {
    0x38, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x34, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BlockTransactions[56] =  {
    0x38, ____, ____, ____, 0x10, ____, ____, ____, 0x30, ____, ____, ____,
    0x34, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetBlockProposal[48] =  {
    0x30, ____, ____, ____, 0x0c, ____, ____, ____, 0x2c, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_BlockProposal[12] =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_IndexTransaction[84] =  {
    0x54, ____, ____, ____, 0x0c, ____, ____, ____, 0x10, ____, ____, ____,
    ____, ____, ____, ____, 0x44, ____, ____, ____, 0x0c, ____, ____, ____,
    0x40, ____, ____, ____, 0x34, ____, ____, ____, 0x1c, ____, ____, ____,
    0x20, ____, ____, ____, 0x24, ____, ____, ____, 0x28, ____, ____, ____,
    0x2c, ____, ____, ____, 0x30, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    0x04, ____, ____, ____, 0x04, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_IndexTransactionVec[4] =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_SyncMessage[52]  =  {
    ____, ____, ____, ____, 0x30, ____, ____, ____, 0x0c, ____, ____, ____,
    0x2c, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetHeaders[48]   =  {
    0x30, ____, ____, ____, 0x0c, ____, ____, ____, 0x2c, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetBlocks[12]    =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_SendHeaders[12]  =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_SendBlock[248]   =  {
    0xf8, ____, ____, ____, 0x08, ____, ____, ____, 0xf0, ____, ____, ____,
    0x14, ____, ____, ____, 0xe4, ____, ____, ____, 0xe8, ____, ____, ____,
    0xec, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
    0x04, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_SetFilter[25]    =  {
    0x19, ____, ____, ____, 0x10, ____, ____, ____, 0x14, ____, ____, ____,
    0x18, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_AddFilter[12]    =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_ClearFilter[4]   =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_FilteredBlock[248] =  {
    0xf8, ____, ____, ____, 0x10, ____, ____, ____, 0xe0, ____, ____, ____,
    0xe4, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
    0x14, ____, ____, ____, 0x0c, ____, ____, ____, 0x10, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_MerkleProof[20]  =  {
    0x14, ____, ____, ____, 0x0c, ____, ____, ____, 0x10, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_InIBD[4]         =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Time[16]         =  {
    0x10, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_RawAlert[56]     =  {
    0x38, ____, ____, ____, 0x20, ____, ____, ____, 0x28, ____, ____, ____,
    0x2c, ____, ____, ____, 0x30, ____, ____, ____, 0x34, ____, ____, ____,
    0x38, ____, ____, ____, 0x38, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Alert[72]        =  {
    0x48, ____, ____, ____, 0x0c, ____, ____, ____, 0x44, ____, ____, ____,
    0x38, ____, ____, ____, 0x20, ____, ____, ____, 0x28, ____, ____, ____,
    0x2c, ____, ____, ____, 0x30, ____, ____, ____, 0x34, ____, ____, ____,
    0x38, ____, ____, ____, 0x38, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Identify[32]     =  {
    0x20, ____, ____, ____, 0x10, ____, ____, ____, 0x18, ____, ____, ____,
    0x1c, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____, ____, ____, ____, ____,
};

#undef ____

/*
 * Reader Functions
 */

MOLECULE_API_DECORATOR mol_errno MolReader_BoolOpt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Bool_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_Byte32Opt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Byte32_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellOutputOpt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_CellOutput_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_UncleBlockVecView_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_UncleBlockVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_TransactionView_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Transaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_BlockExt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 5) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 5) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint256_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_Uint64Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_BoolOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellEntry_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 6) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 6) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_CellOutput_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[5];
        inner.size = offsets[6] - offsets[5];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_CellDataEntry_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RelayMessage_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    mol_num_t item_id = mol_unpack_number(input->ptr);
    mol_seg_t inner;
    inner.ptr = input->ptr + MOL_NUM_T_SIZE;
    inner.size = input->size - MOL_NUM_T_SIZE;
    switch(item_id) {
        case 0:
            return MolReader_CompactBlock_verify(&inner, compatible);
        case 1:
            return MolReader_RelayTransactions_verify(&inner, compatible);
        case 2:
            return MolReader_RelayTransactionHashes_verify(&inner, compatible);
        case 3:
            return MolReader_GetRelayTransactions_verify(&inner, compatible);
        case 4:
            return MolReader_GetBlockTransactions_verify(&inner, compatible);
        case 5:
            return MolReader_BlockTransactions_verify(&inner, compatible);
        case 6:
            return MolReader_GetBlockProposal_verify(&inner, compatible);
        case 7:
            return MolReader_BlockProposal_verify(&inner, compatible);
        default:
            return MOL_ERR_UNKNOWN_ITEM;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_CompactBlock_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 5) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 5) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Header_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_IndexTransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_CompactBlockV1_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 6) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 6) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Header_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_IndexTransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[5];
        inner.size = offsets[6] - offsets[5];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RelayTransaction_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Transaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RelayTransactionVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_RelayTransaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_RelayTransaction_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_RelayTransactions_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_RelayTransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RelayTransactionHashes_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetRelayTransactions_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetBlockTransactions_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Uint32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Uint32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_BlockTransactions_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_TransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_UncleBlockVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetBlockProposal_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_ProposalShortIdVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_BlockProposal_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_TransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_IndexTransaction_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Transaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_IndexTransactionVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_IndexTransaction_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_IndexTransaction_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_SyncMessage_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    mol_num_t item_id = mol_unpack_number(input->ptr);
    mol_seg_t inner;
    inner.ptr = input->ptr + MOL_NUM_T_SIZE;
    inner.size = input->size - MOL_NUM_T_SIZE;
    switch(item_id) {
        case 0:
            return MolReader_GetHeaders_verify(&inner, compatible);
        case 1:
            return MolReader_SendHeaders_verify(&inner, compatible);
        case 2:
            return MolReader_GetBlocks_verify(&inner, compatible);
        case 3:
            return MolReader_SendBlock_verify(&inner, compatible);
        case 4:
            return MolReader_SetFilter_verify(&inner, compatible);
        case 5:
            return MolReader_AddFilter_verify(&inner, compatible);
        case 6:
            return MolReader_ClearFilter_verify(&inner, compatible);
        case 7:
            return MolReader_FilteredBlock_verify(&inner, compatible);
        case 8:
            return MolReader_InIBD_verify(&inner, compatible);
        default:
            return MOL_ERR_UNKNOWN_ITEM;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetHeaders_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetBlocks_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_SendHeaders_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_HeaderVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_SendBlock_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Block_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_SetFilter_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        if (offsets[3] - offsets[2] != 1) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_AddFilter_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_ClearFilter_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 0) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 0) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_FilteredBlock_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Header_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_TransactionVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_MerkleProof_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_MerkleProof_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Byte32Vec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_InIBD_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 0) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 0) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Time_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_RawAlert_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 7) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 7) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[3];
        inner.size = offsets[4] - offsets[3];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[4];
        inner.size = offsets[5] - offsets[4];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[5];
        inner.size = offsets[6] - offsets[5];
        errno = MolReader_BytesOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[6];
        inner.size = offsets[7] - offsets[6];
        errno = MolReader_BytesOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Alert_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_RawAlert_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_BytesVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Identify_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint64_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}

/*
 * Builder Functions
 */

MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_UncleBlockVecView_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_UncleBlockVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_TransactionView_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 68 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 68 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 68;
        memcpy(dst, &MolDefault_Transaction, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_BlockExt_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 24;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 0 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 0 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Uint256, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint64Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BoolOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_CellEntry_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 28;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 77 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[11];
    res.seg.size += len == 0 ? 8 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 77 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[11];
    offset += len == 0 ? 8 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 77;
        memcpy(dst, &MolDefault_CellOutput, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[11];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[10];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_CellDataEntry_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 32 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 32 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_CompactBlock_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 24;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 208 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 208 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 208;
        memcpy(dst, &MolDefault_Header, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_IndexTransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_CompactBlockV1_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 28;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 208 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[11];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 208 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[11];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 208;
        memcpy(dst, &MolDefault_Header, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_IndexTransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[11];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[10];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_RelayTransaction_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 68 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 68 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 68;
        memcpy(dst, &MolDefault_Transaction, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_RelayTransactions_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_RelayTransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_RelayTransactionHashes_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetRelayTransactions_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetBlockTransactions_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_BlockTransactions_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_TransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_UncleBlockVec, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetBlockProposal_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_ProposalShortIdVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_BlockProposal_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_TransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_IndexTransaction_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 68 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 68 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 68;
        memcpy(dst, &MolDefault_Transaction, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetHeaders_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 32 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 32 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 32;
        memcpy(dst, &MolDefault_Byte32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetBlocks_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_SendHeaders_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_HeaderVec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_SendBlock_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 240 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 240 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 240;
        memcpy(dst, &MolDefault_Block, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_SetFilter_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 1 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 1 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 1;
        *dst = 0;
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_AddFilter_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_ClearFilter_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 4;
    res.seg.size = offset;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_FilteredBlock_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 208 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 20 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 208 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 20 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 208;
        memcpy(dst, &MolDefault_Header, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_TransactionVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 20;
        memcpy(dst, &MolDefault_MerkleProof, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_MerkleProof_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Byte32Vec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_InIBD_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 4;
    res.seg.size = offset;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Time_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 8 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 8 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_RawAlert_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 32;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[7];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[9];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[11];
    res.seg.size += len == 0 ? 0 : len;
    len = builder.number_ptr[13];
    res.seg.size += len == 0 ? 0 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[7];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[9];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[11];
    offset += len == 0 ? 0 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[13];
    offset += len == 0 ? 0 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[7];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[6];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[9];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[8];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[11];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BytesOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[10];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[13];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_BytesOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[12];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Alert_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 56 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 56 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 56;
        memcpy(dst, &MolDefault_RawAlert, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_BytesVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Identify_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 8 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 8 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 8;
        memcpy(dst, &MolDefault_Uint64, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}

#ifdef __DEFINE_MOLECULE_API_DECORATOR_EXTENSIONS
#undef MOLECULE_API_DECORATOR
#undef __DEFINE_MOLECULE_API_DECORATOR_EXTENSIONS
#endif /* __DEFINE_MOLECULE_API_DECORATOR_EXTENSIONS */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* EXTENSIONS_H */
