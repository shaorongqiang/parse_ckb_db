// Generated by Molecule 0.7.3

#define MOLECULEC_VERSION 7003
#define MOLECULE_API_VERSION_MIN 7000

#include "molecule_reader.h"
#include "molecule_builder.h"

#ifndef PROTOCOLS_H
#define PROTOCOLS_H

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef MOLECULE_API_DECORATOR
#define __DEFINE_MOLECULE_API_DECORATOR_PROTOCOLS
#define MOLECULE_API_DECORATOR
#endif /* MOLECULE_API_DECORATOR */

#include "blockchain.h"
#include "extensions.h"

/*
 * Reader APIs
 */

MOLECULE_API_DECORATOR  mol_errno       MolReader_PingPayload_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_PingPayload_unpack(s)                 mol_union_unpack(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_PingMessage_verify                    (const mol_seg_t*, bool);
#define                                 MolReader_PingMessage_actual_field_count(s)     mol_table_actual_field_count(s)
#define                                 MolReader_PingMessage_has_extra_fields(s)       mol_table_has_extra_fields(s, 1)
#define                                 MolReader_PingMessage_get_payload(s)            mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Ping_verify                           (const mol_seg_t*, bool);
#define                                 MolReader_Ping_actual_field_count(s)            mol_table_actual_field_count(s)
#define                                 MolReader_Ping_has_extra_fields(s)              mol_table_has_extra_fields(s, 1)
#define                                 MolReader_Ping_get_nonce(s)                     mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Pong_verify                           (const mol_seg_t*, bool);
#define                                 MolReader_Pong_actual_field_count(s)            mol_table_actual_field_count(s)
#define                                 MolReader_Pong_has_extra_fields(s)              mol_table_has_extra_fields(s, 1)
#define                                 MolReader_Pong_get_nonce(s)                     mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_NodeVec_verify                        (const mol_seg_t*, bool);
#define                                 MolReader_NodeVec_length(s)                     mol_dynvec_length(s)
#define                                 MolReader_NodeVec_get(s, i)                     mol_dynvec_slice_by_index(s, i)
#define                                 MolReader_Uint16_verify(s, c)                   mol_verify_fixed_size(s, 2)
#define                                 MolReader_Uint16_get_nth0(s)                    mol_slice_by_offset(s, 0, 1)
#define                                 MolReader_Uint16_get_nth1(s)                    mol_slice_by_offset(s, 1, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_PortOpt_verify                        (const mol_seg_t*, bool);
#define                                 MolReader_PortOpt_is_none(s)                    mol_option_is_none(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_DiscoveryPayload_verify               (const mol_seg_t*, bool);
#define                                 MolReader_DiscoveryPayload_unpack(s)            mol_union_unpack(s)
MOLECULE_API_DECORATOR  mol_errno       MolReader_DiscoveryMessage_verify               (const mol_seg_t*, bool);
#define                                 MolReader_DiscoveryMessage_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_DiscoveryMessage_has_extra_fields(s)  mol_table_has_extra_fields(s, 1)
#define                                 MolReader_DiscoveryMessage_get_payload(s)       mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_GetNodes_verify                       (const mol_seg_t*, bool);
#define                                 MolReader_GetNodes_actual_field_count(s)        mol_table_actual_field_count(s)
#define                                 MolReader_GetNodes_has_extra_fields(s)          mol_table_has_extra_fields(s, 3)
#define                                 MolReader_GetNodes_get_version(s)               mol_table_slice_by_index(s, 0)
#define                                 MolReader_GetNodes_get_count(s)                 mol_table_slice_by_index(s, 1)
#define                                 MolReader_GetNodes_get_listen_port(s)           mol_table_slice_by_index(s, 2)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Nodes_verify                          (const mol_seg_t*, bool);
#define                                 MolReader_Nodes_actual_field_count(s)           mol_table_actual_field_count(s)
#define                                 MolReader_Nodes_has_extra_fields(s)             mol_table_has_extra_fields(s, 2)
#define                                 MolReader_Nodes_get_announce(s)                 mol_table_slice_by_index(s, 0)
#define                                 MolReader_Nodes_get_items(s)                    mol_table_slice_by_index(s, 1)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Node_verify                           (const mol_seg_t*, bool);
#define                                 MolReader_Node_actual_field_count(s)            mol_table_actual_field_count(s)
#define                                 MolReader_Node_has_extra_fields(s)              mol_table_has_extra_fields(s, 1)
#define                                 MolReader_Node_get_addresses(s)                 mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_AddressVec_verify                     (const mol_seg_t*, bool);
#define                                 MolReader_AddressVec_length(s)                  mol_dynvec_length(s)
#define                                 MolReader_AddressVec_get(s, i)                  mol_dynvec_slice_by_index(s, i)
MOLECULE_API_DECORATOR  mol_errno       MolReader_Address_verify                        (const mol_seg_t*, bool);
#define                                 MolReader_Address_actual_field_count(s)         mol_table_actual_field_count(s)
#define                                 MolReader_Address_has_extra_fields(s)           mol_table_has_extra_fields(s, 1)
#define                                 MolReader_Address_get_bytes(s)                  mol_table_slice_by_index(s, 0)
MOLECULE_API_DECORATOR  mol_errno       MolReader_IdentifyMessage_verify                (const mol_seg_t*, bool);
#define                                 MolReader_IdentifyMessage_actual_field_count(s) mol_table_actual_field_count(s)
#define                                 MolReader_IdentifyMessage_has_extra_fields(s)   mol_table_has_extra_fields(s, 3)
#define                                 MolReader_IdentifyMessage_get_listen_addrs(s)   mol_table_slice_by_index(s, 0)
#define                                 MolReader_IdentifyMessage_get_observed_addr(s)  mol_table_slice_by_index(s, 1)
#define                                 MolReader_IdentifyMessage_get_identify(s)       mol_table_slice_by_index(s, 2)

/*
 * Builder APIs
 */

#define                                 MolBuilder_PingPayload_init(b)                  mol_union_builder_initialize(b, 16, 0, &MolDefault_Ping, 12)
#define                                 MolBuilder_PingPayload_set_Ping(b, p, l)        mol_union_builder_set(b, 0, p, l)
#define                                 MolBuilder_PingPayload_set_Pong(b, p, l)        mol_union_builder_set(b, 1, p, l)
#define                                 MolBuilder_PingPayload_build(b)                 mol_builder_finalize_simple(b)
#define                                 MolBuilder_PingPayload_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_PingMessage_init(b)                  mol_table_builder_initialize(b, 128, 1)
#define                                 MolBuilder_PingMessage_set_payload(b, p, l)     mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_PingMessage_build                    (mol_builder_t);
#define                                 MolBuilder_PingMessage_clear(b)                 mol_builder_discard(b)
#define                                 MolBuilder_Ping_init(b)                         mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_Ping_set_nonce(b, p, l)              mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Ping_build                           (mol_builder_t);
#define                                 MolBuilder_Ping_clear(b)                        mol_builder_discard(b)
#define                                 MolBuilder_Pong_init(b)                         mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_Pong_set_nonce(b, p, l)              mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Pong_build                           (mol_builder_t);
#define                                 MolBuilder_Pong_clear(b)                        mol_builder_discard(b)
#define                                 MolBuilder_NodeVec_init(b)                      mol_builder_initialize_with_capacity(b, 256, 64)
#define                                 MolBuilder_NodeVec_push(b, p, l)                mol_dynvec_builder_push(b, p, l)
#define                                 MolBuilder_NodeVec_build(b)                     mol_dynvec_builder_finalize(b)
#define                                 MolBuilder_NodeVec_clear(b)                     mol_builder_discard(b)
#define                                 MolBuilder_Uint16_init(b)                       mol_builder_initialize_fixed_size(b, 2)
#define                                 MolBuilder_Uint16_set_nth0(b, p)                mol_builder_set_byte_by_offset(b, 0, p)
#define                                 MolBuilder_Uint16_set_nth1(b, p)                mol_builder_set_byte_by_offset(b, 1, p)
#define                                 MolBuilder_Uint16_build(b)                      mol_builder_finalize_simple(b)
#define                                 MolBuilder_Uint16_clear(b)                      mol_builder_discard(b)
#define                                 MolBuilder_PortOpt_init(b)                      mol_builder_initialize_fixed_size(b, 0)
#define                                 MolBuilder_PortOpt_set(b, p, l)                 mol_option_builder_set(b, p, l)
#define                                 MolBuilder_PortOpt_build(b)                     mol_builder_finalize_simple(b)
#define                                 MolBuilder_PortOpt_clear(b)                     mol_builder_discard(b)
#define                                 MolBuilder_DiscoveryPayload_init(b)             mol_union_builder_initialize(b, 32, 0, &MolDefault_GetNodes, 24)
#define                                 MolBuilder_DiscoveryPayload_set_GetNodes(b, p, l) mol_union_builder_set(b, 0, p, l)
#define                                 MolBuilder_DiscoveryPayload_set_Nodes(b, p, l)  mol_union_builder_set(b, 1, p, l)
#define                                 MolBuilder_DiscoveryPayload_build(b)            mol_builder_finalize_simple(b)
#define                                 MolBuilder_DiscoveryPayload_clear(b)            mol_builder_discard(b)
#define                                 MolBuilder_DiscoveryMessage_init(b)             mol_table_builder_initialize(b, 256, 1)
#define                                 MolBuilder_DiscoveryMessage_set_payload(b, p, l) mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_DiscoveryMessage_build               (mol_builder_t);
#define                                 MolBuilder_DiscoveryMessage_clear(b)            mol_builder_discard(b)
#define                                 MolBuilder_GetNodes_init(b)                     mol_table_builder_initialize(b, 128, 3)
#define                                 MolBuilder_GetNodes_set_version(b, p, l)        mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_GetNodes_set_count(b, p, l)          mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_GetNodes_set_listen_port(b, p, l)    mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_GetNodes_build                       (mol_builder_t);
#define                                 MolBuilder_GetNodes_clear(b)                    mol_builder_discard(b)
#define                                 MolBuilder_Nodes_init(b)                        mol_table_builder_initialize(b, 128, 2)
#define                                 MolBuilder_Nodes_set_announce(b, p, l)          mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_Nodes_set_items(b, p, l)             mol_table_builder_add(b, 1, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Nodes_build                          (mol_builder_t);
#define                                 MolBuilder_Nodes_clear(b)                       mol_builder_discard(b)
#define                                 MolBuilder_Node_init(b)                         mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_Node_set_addresses(b, p, l)          mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Node_build                           (mol_builder_t);
#define                                 MolBuilder_Node_clear(b)                        mol_builder_discard(b)
#define                                 MolBuilder_AddressVec_init(b)                   mol_builder_initialize_with_capacity(b, 256, 64)
#define                                 MolBuilder_AddressVec_push(b, p, l)             mol_dynvec_builder_push(b, p, l)
#define                                 MolBuilder_AddressVec_build(b)                  mol_dynvec_builder_finalize(b)
#define                                 MolBuilder_AddressVec_clear(b)                  mol_builder_discard(b)
#define                                 MolBuilder_Address_init(b)                      mol_table_builder_initialize(b, 64, 1)
#define                                 MolBuilder_Address_set_bytes(b, p, l)           mol_table_builder_add(b, 0, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_Address_build                        (mol_builder_t);
#define                                 MolBuilder_Address_clear(b)                     mol_builder_discard(b)
#define                                 MolBuilder_IdentifyMessage_init(b)              mol_table_builder_initialize(b, 256, 3)
#define                                 MolBuilder_IdentifyMessage_set_listen_addrs(b, p, l) mol_table_builder_add(b, 0, p, l)
#define                                 MolBuilder_IdentifyMessage_set_observed_addr(b, p, l) mol_table_builder_add(b, 1, p, l)
#define                                 MolBuilder_IdentifyMessage_set_identify(b, p, l) mol_table_builder_add(b, 2, p, l)
MOLECULE_API_DECORATOR  mol_seg_res_t   MolBuilder_IdentifyMessage_build                (mol_builder_t);
#define                                 MolBuilder_IdentifyMessage_clear(b)             mol_builder_discard(b)

/*
 * Default Value
 */

#define ____ 0x00

MOLECULE_API_DECORATOR const uint8_t MolDefault_PingPayload[16]  =  {
    ____, ____, ____, ____, 0x0c, ____, ____, ____, 0x08, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_PingMessage[24]  =  {
    0x18, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Ping[12]         =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Pong[12]         =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_NodeVec[4]       =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Uint16[2]        =  {____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_PortOpt[0]       =  {};
MOLECULE_API_DECORATOR const uint8_t MolDefault_DiscoveryPayload[28] =  {
    ____, ____, ____, ____, 0x18, ____, ____, ____, 0x10, ____, ____, ____,
    0x14, ____, ____, ____, 0x18, ____, ____, ____, ____, ____, ____, ____,
    ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_DiscoveryMessage[36] =  {
    0x24, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
    0x18, ____, ____, ____, 0x10, ____, ____, ____, 0x14, ____, ____, ____,
    0x18, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_GetNodes[24]     =  {
    0x18, ____, ____, ____, 0x10, ____, ____, ____, 0x14, ____, ____, ____,
    0x18, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Nodes[17]        =  {
    0x11, ____, ____, ____, 0x0c, ____, ____, ____, 0x0d, ____, ____, ____,
    ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Node[12]         =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, 0x04, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_AddressVec[4]    =  {0x04, ____, ____, ____};
MOLECULE_API_DECORATOR const uint8_t MolDefault_Address[12]      =  {
    0x0c, ____, ____, ____, 0x08, ____, ____, ____, ____, ____, ____, ____,
};
MOLECULE_API_DECORATOR const uint8_t MolDefault_IdentifyMessage[36] =  {
    0x24, ____, ____, ____, 0x10, ____, ____, ____, 0x14, ____, ____, ____,
    0x20, ____, ____, ____, 0x04, ____, ____, ____, 0x0c, ____, ____, ____,
    0x08, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____,
};

#undef ____

/*
 * Reader Functions
 */

MOLECULE_API_DECORATOR mol_errno MolReader_PingPayload_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    mol_num_t item_id = mol_unpack_number(input->ptr);
    mol_seg_t inner;
    inner.ptr = input->ptr + MOL_NUM_T_SIZE;
    inner.size = input->size - MOL_NUM_T_SIZE;
    switch(item_id) {
        case 0:
            return MolReader_Ping_verify(&inner, compatible);
        case 1:
            return MolReader_Pong_verify(&inner, compatible);
        default:
            return MOL_ERR_UNKNOWN_ITEM;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_PingMessage_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_PingPayload_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Ping_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Pong_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_NodeVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Node_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Node_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_PortOpt_verify (const mol_seg_t *input, bool compatible) {
    if (input->size != 0) {
        return MolReader_Uint16_verify(input, compatible);
    } else {
        return MOL_OK;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_DiscoveryPayload_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    mol_num_t item_id = mol_unpack_number(input->ptr);
    mol_seg_t inner;
    inner.ptr = input->ptr + MOL_NUM_T_SIZE;
    inner.size = input->size - MOL_NUM_T_SIZE;
    switch(item_id) {
        case 0:
            return MolReader_GetNodes_verify(&inner, compatible);
        case 1:
            return MolReader_Nodes_verify(&inner, compatible);
        default:
            return MOL_ERR_UNKNOWN_ITEM;
    }
}
MOLECULE_API_DECORATOR mol_errno MolReader_DiscoveryMessage_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_DiscoveryPayload_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_GetNodes_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Uint32_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_PortOpt_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Nodes_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 2) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 2) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Bool_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_NodeVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_Node_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_BytesVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_AddressVec_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size == MOL_NUM_T_SIZE) {
        return MOL_OK;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t item_count = offset / 4 - 1;
    if (input->size < MOL_NUM_T_SIZE*(item_count+1)) {
        return MOL_ERR_HEADER;
    }
    mol_num_t end;
    for (mol_num_t i=1; i<item_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        end = mol_unpack_number(ptr);
        if (offset > end) {
            return MOL_ERR_OFFSET;
        }
        mol_seg_t inner;
        inner.ptr = input->ptr + offset;
        inner.size = end - offset;
        mol_errno errno = MolReader_Address_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        offset = end;
    }
    if (offset > total_size) {
        return MOL_ERR_OFFSET;
    }
    mol_seg_t inner;
    inner.ptr = input->ptr + offset;
    inner.size = total_size - offset;
    return MolReader_Address_verify(&inner, compatible);
}
MOLECULE_API_DECORATOR mol_errno MolReader_Address_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 1) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 1) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}
MOLECULE_API_DECORATOR mol_errno MolReader_IdentifyMessage_verify (const mol_seg_t *input, bool compatible) {
    if (input->size < MOL_NUM_T_SIZE) {
        return MOL_ERR_HEADER;
    }
    uint8_t *ptr = input->ptr;
    mol_num_t total_size = mol_unpack_number(ptr);
    if (input->size != total_size) {
        return MOL_ERR_TOTAL_SIZE;
    }
    if (input->size < MOL_NUM_T_SIZE * 2) {
        return MOL_ERR_HEADER;
    }
    ptr += MOL_NUM_T_SIZE;
    mol_num_t offset = mol_unpack_number(ptr);
    if (offset % 4 > 0 || offset < MOL_NUM_T_SIZE*2) {
        return MOL_ERR_OFFSET;
    }
    mol_num_t field_count = offset / 4 - 1;
    if (field_count < 3) {
        return MOL_ERR_FIELD_COUNT;
    } else if (!compatible && field_count > 3) {
        return MOL_ERR_FIELD_COUNT;
    }
    if (input->size < MOL_NUM_T_SIZE*(field_count+1)){
        return MOL_ERR_HEADER;
    }
    mol_num_t offsets[field_count+1];
    offsets[0] = offset;
    for (mol_num_t i=1; i<field_count; i++) {
        ptr += MOL_NUM_T_SIZE;
        offsets[i] = mol_unpack_number(ptr);
        if (offsets[i-1] > offsets[i]) {
            return MOL_ERR_OFFSET;
        }
    }
    if (offsets[field_count-1] > total_size) {
        return MOL_ERR_OFFSET;
    }
    offsets[field_count] = total_size;
        mol_seg_t inner;
        mol_errno errno;
        inner.ptr = input->ptr + offsets[0];
        inner.size = offsets[1] - offsets[0];
        errno = MolReader_AddressVec_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[1];
        inner.size = offsets[2] - offsets[1];
        errno = MolReader_Address_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
        inner.ptr = input->ptr + offsets[2];
        inner.size = offsets[3] - offsets[2];
        errno = MolReader_Bytes_verify(&inner, compatible);
        if (errno != MOL_OK) {
            return MOL_ERR_DATA;
        }
    return MOL_OK;
}

/*
 * Builder Functions
 */

MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_PingMessage_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 16 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 16 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 16;
        memcpy(dst, &MolDefault_PingPayload, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Ping_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Pong_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_DiscoveryMessage_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 28 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 28 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 28;
        memcpy(dst, &MolDefault_DiscoveryPayload, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_GetNodes_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 0 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 0 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Uint32, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 0;
        memcpy(dst, &MolDefault_PortOpt, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Nodes_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 12;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 1 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 1 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 1;
        memcpy(dst, &MolDefault_Bool, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_NodeVec, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Node_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_BytesVec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_Address_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 8;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}
MOLECULE_API_DECORATOR mol_seg_res_t MolBuilder_IdentifyMessage_build (mol_builder_t builder) {
    mol_seg_res_t res;
    res.errno = MOL_OK;
    mol_num_t offset = 16;
    mol_num_t len;
    res.seg.size = offset;
    len = builder.number_ptr[1];
    res.seg.size += len == 0 ? 4 : len;
    len = builder.number_ptr[3];
    res.seg.size += len == 0 ? 12 : len;
    len = builder.number_ptr[5];
    res.seg.size += len == 0 ? 4 : len;
    res.seg.ptr = (uint8_t*)malloc(res.seg.size);
    uint8_t *dst = res.seg.ptr;
    mol_pack_number(dst, &res.seg.size);
    dst += MOL_NUM_T_SIZE;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[1];
    offset += len == 0 ? 4 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[3];
    offset += len == 0 ? 12 : len;
    mol_pack_number(dst, &offset);
    dst += MOL_NUM_T_SIZE;
    len = builder.number_ptr[5];
    offset += len == 0 ? 4 : len;
    uint8_t *src = builder.data_ptr;
    len = builder.number_ptr[1];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_AddressVec, len);
    } else {
        mol_num_t of = builder.number_ptr[0];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[3];
    if (len == 0) {
        len = 12;
        memcpy(dst, &MolDefault_Address, len);
    } else {
        mol_num_t of = builder.number_ptr[2];
        memcpy(dst, src+of, len);
    }
    dst += len;
    len = builder.number_ptr[5];
    if (len == 0) {
        len = 4;
        memcpy(dst, &MolDefault_Bytes, len);
    } else {
        mol_num_t of = builder.number_ptr[4];
        memcpy(dst, src+of, len);
    }
    dst += len;
    mol_builder_discard(builder);
    return res;
}

#ifdef __DEFINE_MOLECULE_API_DECORATOR_PROTOCOLS
#undef MOLECULE_API_DECORATOR
#undef __DEFINE_MOLECULE_API_DECORATOR_PROTOCOLS
#endif /* __DEFINE_MOLECULE_API_DECORATOR_PROTOCOLS */

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* PROTOCOLS_H */
